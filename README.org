#+TITLE: Sextant - A Common Lisp Language Server
#+AUTHOR: Glenn Thompson
#+OPTIONS: toc:2

* Sextant

A Language Server Protocol (LSP) implementation for Common Lisp, written in Common Lisp.

Sextant runs as an SBCL process that speaks LSP over stdio. It queries its own running
Lisp image for symbol information, giving you a full-featured editing experience in any
LSP-capable editor.

** Features

*** Core
- *Hover documentation* - Symbol type, arglist, docstring (=textDocument/hover=)
- *Completions* - Symbol name completion across all packages (=textDocument/completion=)
- *Completion resolve* - Lazy-load documentation per completion item (=completionItem/resolve=)
- *Go to definition* - Jump to source via SBCL introspection (=textDocument/definition=)
- *Find references* - Who calls, binds, references, macroexpands (=textDocument/references=)
- *Signature help* - Function arglist display (=textDocument/signatureHelp=)
- *Diagnostics* - Compile buffer in sandbox, report errors/warnings (=textDocument/publishDiagnostics=)

*** Navigation & Structure
- *Document symbols* - Outline of all =def*= forms (=textDocument/documentSymbol=)
- *Workspace symbols* - Search symbols across all packages (=workspace/symbol=)
- *Call hierarchy* - Incoming calls via =sb-introspect:who-calls= (=callHierarchy/incomingCalls=)
- *Folding ranges* - Fold top-level forms (=textDocument/foldingRange=)
- *Selection range* - Expand/shrink selection by s-expression (=textDocument/selectionRange=)

*** Editing
- *Rename* - Rename symbol across current file (=textDocument/rename=)
- *Formatting* - S-expression-aware indentation (=textDocument/formatting=)
- *Code actions* - Add package prefix, export symbol, insert defpackage (=textDocument/codeAction=)
- *Linked editing range* - Edit all occurrences simultaneously (=textDocument/linkedEditingRange=)

*** Display
- *Document highlight* - Highlight all occurrences of symbol under cursor (=textDocument/documentHighlight=)
- *Semantic tokens* - Rich highlighting: functions, macros, special forms, variables, keywords, classes (=textDocument/semanticTokens/full=)
- *Inlay hints* - Show parameter names at function call sites (=textDocument/inlayHint=)
- *Code lens* - Reference counts above definitions (=textDocument/codeLens=)

*** Other
- *Incremental document sync* - Efficient partial updates (=change: 2=)
- *Zero external deps at runtime* - Queries the live SBCL image directly
- *No Swank/Slynk required* - Self-contained LSP server

** Requirements

- [[http://www.sbcl.org/][SBCL]]
- [[https://www.quicklisp.org/][Quicklisp]] (for build-time dependencies)

** Building

#+begin_src bash
cd sextant
make
#+end_src

This produces a =sextant= executable (~16MB compressed).

** Emacs Setup (eglot)

#+begin_src emacs-lisp
;; Add to your init.el or config
(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs
               '(lisp-mode . ("/path/to/sextant"))))

;; Auto-start on lisp files (optional)
(add-hook 'lisp-mode-hook 'eglot-ensure)
#+end_src

Or with =lsp-mode=:

#+begin_src emacs-lisp
(with-eval-after-load 'lsp-mode
  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-stdio-connection '("/path/to/sextant"))
    :major-modes '(lisp-mode)
    :server-id 'sextant)))

(add-hook 'lisp-mode-hook #'lsp)
#+end_src

** Neovim Setup (LazyVim)

Add to =~/.config/nvim/lua/plugins/sextant.lua=:

#+begin_src lua
return {
  {
    "neovim/nvim-lspconfig",
    opts = function(_, opts)
      local configs = require("lspconfig.configs")
      if not configs.sextant then
        local util = require("lspconfig.util")
        configs.sextant = {
          default_config = {
            cmd = { "/path/to/sextant" },
            filetypes = { "lisp" },
            root_dir = util.root_pattern(".git", "*.asd", "*.asdf") or util.path.dirname,
            settings = {},
          },
        }
      end
      require("lspconfig").sextant.setup({})
    end,
  },
}
#+end_src

To enable inlay hints in Neovim:

#+begin_src lua
vim.lsp.inlay_hint.enable(true)
#+end_src

** Helix Setup

Add to =~/.config/helix/languages.toml=:

#+begin_src toml
[[language]]
name = "lisp"
language-servers = ["sextant"]

[language-server.sextant]
command = "/path/to/sextant"
#+end_src

** Architecture

#+begin_src text
sextant/
  sextant.asd            ; ASDF system definition
  Makefile               ; Build script
  src/
    package.lisp         ; Package definition
    json.lisp            ; Minimal JSON reader/writer (no deps)
    transport.lisp       ; LSP JSON-RPC over stdio
    document.lisp        ; Open file tracking, s-expression utilities
    lisp-introspection.lisp  ; Query running SBCL for docs/completions/defs/refs
    handlers.lisp        ; LSP method dispatch (all 22 methods)
    server.lisp          ; Main message loop
    main.lisp            ; Entry point
#+end_src

** How It Works

Unlike most language servers that do static analysis, Sextant queries a *live Common Lisp
image*. When you hover over =format=, it calls =(documentation 'format 'function)= and
=(sb-introspect:function-lambda-list 'format)= in its own SBCL process.

This means:
- All of CL's 978 standard symbols are available immediately
- Quicklisp packages can be loaded into the server for their docs too
- Macros, reader macros, and dynamic features Just Work

For diagnostics, Sextant reads each top-level form from the buffer and compiles it in a
sandbox via =(compile nil `(lambda () ,form))=, collecting any errors and warnings.

For references and call hierarchy, it uses =sb-introspect:who-calls=,
=sb-introspect:who-binds=, =sb-introspect:who-references=, and
=sb-introspect:who-macroexpands=.

** Debug Logging

Set =SEXTANT_LOG= to control the log file location:

#+begin_src bash
SEXTANT_LOG=/tmp/sextant.log sextant
#+end_src

Default: =/tmp/sextant.log=

** License

MIT
